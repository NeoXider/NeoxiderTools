# Компонент Timer Object

## 1. Введение

`TimerObject` — это компонент `MonoBehaviour`, который предоставляет простой и наглядный способ создания таймеров прямо в вашей сцене Unity. В отличие от класса `Timer`, который является обычным C#-классом, `TimerObject` можно добавить на любой `GameObject` и настроить все его параметры в инспекторе.

Он идеально подходит для создания кулдаунов, обратных отсчетов, таймеров длительности эффектов или любых других временных механик, которые должны быть привязаны к конкретному объекту в сцене.

---

## 2. Описание класса

### TimerObject
- **Пространство имен**: `Neo`
- **Путь к файлу**: `Assets/Neoxider/Scripts/Tools/Time/TimerObject.cs`

**Описание**
Компонент, который управляет отсчетом времени. Он может считать как вверх, так и вниз, зацикливаться, игнорировать `Time.timeScale` и вызывать `UnityEvent` на ключевых этапах своего жизненного цикла.

**Улучшения в v5.2.21:**
- Исправлен двойной вызов событий при достижении duration в режиме looping
- При looping таймер теперь корректно перезапускается без лишних вызовов событий
- Добавлена секция "Auto Actions" для автоматических действий без кода
- Автоматическая активация/деактивация GameObjects при завершении
- Автоматический перезапуск других TimerObjects
- Добавлена визуальная анимация при старте (scale animation)
- Улучшена автоматическая настройка компонентов

**Ключевые поля**

### Timer Settings
- `duration`: Общая длительность таймера в секундах.
- `updateInterval`: Как часто (в секундах) будет обновляться таймер и вызываться события `OnTimeChanged` и `OnProgressChanged`. Минимум: `0.015`.
- `countUp`: Если `true`, таймер будет считать от 0 до `duration` (время увеличивается). Если `false`, таймер будет считать от `duration` до 0 (обратный отсчёт, время уменьшается). В обратном режиме таймер стартует с `duration` и останавливается на 0.
- `useUnscaledTime`: Если `true`, таймер будет игнорировать `Time.timeScale` (полезно для UI во время паузы).
- `looping`: Если `true`, таймер будет автоматически перезапускаться после завершения.

### Random Duration
- `useRandomDuration`: Если `true`, длительность выбирается случайно при старте (`Play()`/`StartTimer()`). Если `looping = true`, то при каждом новом цикле будет снова выбрана случайная длительность.
- `randomDurationMin`: Минимальная длительность (секунды).
- `randomDurationMax`: Максимальная длительность (секунды).

### Infinite Duration
- `infiniteDuration`: Если `true`, таймер не имеет максимума — время просто увеличивается. Прогресс/процент не обновляются. При включении автоматически отключаются `looping` и `useRandomDuration` (в `OnValidate`).

### Initial State
- `autoStart`: Если `true`, таймер запустится автоматически при включении компонента (`OnEnable`) в Play Mode. По умолчанию: `true`. Это означает, что при повторном `SetActive(true)`/`enabled = true` таймер снова запустится.
- `initialProgress`: Начальный прогресс (0-1). 0 = начало, 1 = конец. В режиме `countUp = true` это стартовая позиция от начала (0 = 0 секунд, 1 = duration). В режиме `countUp = false` это стартовая позиция от конца (0 = duration, 1 = 0 секунд).

### Save (по умолчанию выключено)
- `saveProgress` (по умолчанию `false`): Включить сохранение и восстановление состояния таймера (текущее время и признак «идёт/на паузе»). Работает и при счётчике вверх, и вниз.
- `saveMode`:
  - **Seconds** (по умолчанию): сохраняется **только проведённое в игре время** (текущее значение в секундах). Пока игра закрыта, время не тикает. При загрузке таймер продолжает с сохранённого значения (например: 30 с осталось по кулдауну — вышли, зашли — снова 30 с; или 45 мин набежало в счётчике «время в игре» — вышли, зашли — снова 45 мин).
  - **RealTime**: сохраняется целевое время (UTC). При загрузке оставшееся/пройденное время пересчитывается от текущего момента (время тикает и пока игра закрыта). Пример: обратный отсчёт 90 с, вышел на 1 мин — вернулся, осталось ~30 с; или «время в игре» с момента первого запуска в реальном времени.
- `saveKey`: Уникальный ключ для SaveProvider (обязателен при включённом сохранении). Разные таймеры должны иметь разные ключи.

### Visual Feedback - НОВОЕ в v5.2.21
- `enableStartAnimation`: Включить визуальную анимацию при старте.
- `startAnimationScale`: Множитель масштаба для анимации (0.5-2.0).
- `startAnimationDuration`: Длительность анимации в секундах.

**Публичные методы (Public Methods)**
- `Play()`: Запускает таймер, выставляя стартовое значение по `initialProgress`.
- `SetDuration(float newDuration, bool keepProgress = true)`: Устанавливает длительность. `keepProgress = true` сохраняет соотношение прогресса.
- `Pause(bool paused = true)`: Ставит таймер на паузу (`true`) или снимает с паузы (`false`).
- `TogglePause()`: Переключает состояние паузы.
- `Stop()`: Останавливает таймер и сбрасывает его.
- `Reset()`: Сбрасывает таймер в начальное состояние, учитывая `initialProgress` (и обновляет UI/события).
- `StartTimer(float newDuration = -1, float newUpdateInterval = -1)`: Сбрасывает и запускает таймер, опционально меняя `duration`/`updateInterval`.
- `SetTime(float time)`: Устанавливает текущее значение времени таймера.
- `GetProgress()`: Возвращает текущий прогресс таймера (от 0 до 1).
- `GetCurrentTime()`: Возвращает текущее значение времени таймера. В режиме `countUp = true` это прошедшее время (0 → duration), в режиме `countUp = false` это оставшееся время (duration → 0).
- `GetRemainingTime()`: Возвращает оставшееся время до завершения. В режиме `countUp = true` это `duration - currentTime`, в режиме `countUp = false` это `currentTime`.

**Unity Events**
- `OnTimerStarted`: Вызывается в момент запуска таймера.
- `OnTimerPaused`: Вызывается при постановке таймера на паузу.
- `OnTimeChanged` (`UnityEvent<float>`): Вызывается с интервалом `updateInterval` пока таймер активен. Передает текущее значение времени.
- `OnProgressChanged` (`UnityEvent<float>`): Вызывается с интервалом `updateInterval` пока таймер активен. Передает текущий прогресс (от 0 до 1).
- `OnTimerCompleted`: Вызывается, когда таймер завершает отсчет. **Важно**: Вызывается при каждом завершении цикла, включая случаи зацикливания (`looping = true`). Если таймер зациклен, событие будет вызываться каждый раз при достижении `duration`.

**Наследование (v5.8.15)**  
Для производных классов доступны: `protected virtual string GetSaveKey()` — ключ сохранения (переопределите для своего ключа); `protected virtual void SaveState()` — запись состояния в SaveProvider (можно вызывать после `SetTime()` для перезапуска кулдауна); поля `saveProgress` и `saveMode` — `protected`, можно задавать в наследнике. Пример: компонент **CooldownReward** (Bonus) наследует TimerObject и реализует награды по кулдауну с собственным ключом `LastRewardTime` + суффикс.

---

## 3. Как использовать

### Базовое использование (без кода)

1.  Добавьте компонент `TimerObject` на любой `GameObject` в вашей сцене.
2.  Настройте `duration`, `updateInterval`, `countUp`, `useUnscaledTime` и `looping` в инспекторе.
3.  **Для автоматического обновления UI**: 
    - Добавьте компонент `Image` на тот же объект для прогресс-бара (автоматически найдет)
    - Или добавьте `TMP_Text` для отображения времени (автоматически найдет)
    - Настройте `timeFormat` для форматирования текста
4.  **Для визуальной анимации** (v5.2.21):
    - Включите `enableStartAnimation`
    - Настройте `startAnimationScale` и `startAnimationDuration`

### Использование через код

```csharp
// Получить текущий прогресс
float progress = timerObject.Progress;

// Установить время
timerObject.SetTime(5.0f);

// Добавить время
timerObject.AddTime(2.0f);

// Подписаться на события
timerObject.OnTimerCompleted.AddListener(() => {
    Debug.Log("Таймер завершен!");
});
```

---

## 4. Способы применения и настройки сохранения

Ниже — типичные сценарии и рекомендуемые настройки **Save** и таймера.

### 4.1 Проведённое время в игре (только секунды в сессии)

**Задача:** считать, сколько всего секунд игрок провёл в игре. При выходе из игры время не должно расти — только то, что реально прошло в активной игре.

| Параметр | Значение |
|----------|----------|
| `countUp` | `true` |
| `infiniteDuration` | `true` |
| `saveProgress` | `true` |
| `saveMode` | **Seconds** |
| `saveKey` | например `"PlayTime"` |

При закрытии игры сохраняются накопленные секунды. При следующем запуске таймер продолжает с этого значения. Время, пока приложение было закрыто, не добавляется.

---

### 4.2 Кулдаун способности (остаток в секундах)

**Задача:** кулдаун 30 с. Игрок вышел из игры с 15 с остатка — при возврате снова 15 с (не 30 и не 0).

| Параметр | Значение |
|----------|----------|
| `countUp` | `false` |
| `duration` | `30` |
| `saveProgress` | `true` |
| `saveMode` | **Seconds** |
| `saveKey` | например `"AbilityCooldown"` |

Сохраняется текущее значение (оставшиеся секунды) и признак «идёт/на паузе». После загрузки таймер продолжает с того же остатка.

---

### 4.3 Обратный отсчёт до события в реальном времени

**Задача:** «через 1 час наступит событие». Игрок может закрыть игру; при возврате должно показываться, сколько осталось до того же реального момента окончания.

| Параметр | Значение |
|----------|----------|
| `countUp` | `false` |
| `duration` | `3600` (или нужное число секунд) |
| `saveProgress` | `true` |
| `saveMode` | **RealTime** |
| `saveKey` | например `"EventCountdown"` |

Сохраняется время окончания (UTC). При загрузке оставшееся время считается от текущего момента. Закрыл игру на 50 мин — вернулся через 10 мин — осталось 0 (событие уже «наступило» по времени).

---

### 4.4 Сессия с лимитом по реальному времени

**Задача:** «у игрока 1 час сессии с момента входа» — таймер идёт вверх, лимит 3600 с, учитывается реальное время (в т.ч. когда игра закрыта).

| Параметр | Значение |
|----------|----------|
| `countUp` | `true` |
| `duration` | `3600` |
| `saveProgress` | `true` |
| `saveMode` | **RealTime** |
| `saveKey` | например `"SessionLimit"` |

Сохраняется момент старта (UTC). При загрузке прошедшее время = реально прошедшее с того момента, ограниченное `duration`. Закрыл игру на 20-й минуте, вернулся через 50 мин — таймер покажет 60 мин (лимит достигнут).

---

### 4.5 Общее «время в игре» в реальном времени (без лимита)

**Задача:** накопительный счётчик «сколько всего реального времени прошло с первого запуска» (в т.ч. когда игра была закрыта).

| Параметр | Значение |
|----------|----------|
| `countUp` | `true` |
| `infiniteDuration` | `true` |
| `saveProgress` | `true` |
| `saveMode` | **RealTime** |
| `saveKey` | например `"TotalRealPlayTime"` |

Сохраняется момент первого старта (UTC). При каждой загрузке значение = реально прошедшее время с того момента.

---

### 4.6 Прогресс уровня с паузой (только время в игре)

**Задача:** на уровень дано 2 минуты; сохраняем, сколько из них уже прошло. При выходе и возврате продолжаем с того же числа секунд (время вне игры не идёт).

| Параметр | Значение |
|----------|----------|
| `countUp` | `true` |
| `duration` | `120` |
| `saveProgress` | `true` |
| `saveMode` | **Seconds** |
| `saveKey` | например `"LevelTimer"` |

Сохраняются пройденные секунды и состояние (идёт/на паузе). При загрузке таймер продолжает с сохранённого значения в пределах 0…duration.

---

### 4.7 Краткая сводка

| Цель | countUp | infiniteDuration | saveMode |
|------|---------|------------------|----------|
| Проведённое время в игре (только в сессии) | `true` | `true` | **Seconds** |
| Кулдаун, остаток в секундах | `false` | — | **Seconds** |
| Обратный отсчёт до момента в реальном времени | `false` | — | **RealTime** |
| Сессия с лимитом по реальному времени | `true` | `false` | **RealTime** |
| Общее реальное время с первого запуска | `true` | `true` | **RealTime** |
| Прогресс уровня (секунды в игре) | `true` | `false` | **Seconds** |

