# Предложения по скриптам Tools/Components

Рекомендации по доработке скриптов для соответствия документации, устойчивости и удобству использования. Пункты, отмеченные как **Выполнено**, внедрены в коде.

---

## ScoreManager

### SetBestScore(int? score) — логика параметра — **Выполнено**

**Проблема (исправлено):** При вызове `SetBestScore(100)` аргумент игнорируется: внутри выполняется `if (score != null) score = this.score`, после чего всегда используется текущий счёт. Установить рекорд в произвольное значение из кода нельзя.

**Предложение:** Развести поведение: без аргумента — обновить рекорд из текущего счёта; с аргументом — принять переданное значение как кандидат на рекорд (или явно задать рекорд).

Вариант 1 — использовать переданное значение как кандидат:
```csharp
public void SetBestScore(int? candidate = null)
{
    int value = candidate ?? score;
    if (value > _bestScore)
    {
        BestScore = value;
        SaveProvider.SetInt(_keySave, _bestScore);
        SetBestScoreText();
    }
}
```
Тогда `SetBestScore()` обновляет рекорд из текущего счёта, `SetBestScore(100)` — выставляет рекорд в 100, если он больше текущего.

Вариант 2 — явный метод для принудительной установки рекорда: оставить `SetBestScore()` только для «обновить из текущего счёта», добавить `SetBestScoreForce(int value)` для установки рекорда без сравнения (например, для загрузки или читов).

### ResetScore() — лишний вызов события — **Выполнено**

В `ResetScore()` после `Score = 0` вызывается `OnValueChange?.Invoke(score)`. Сеттер `Score` уже вызывает `OnValueChange` и `OnProgressChange`, поэтому подписчики получают дублирующее уведомление. Достаточно оставить `Score = 0` и `SetScoreText()`.

---

## Counter

### Сохранение: вызов SaveProvider.Save() — **Выполнено**

**Проблема (исправлено):** В документации указано: при изменении значения вызываются `SaveProvider.SetFloat(key, value)` и `SaveProvider.Save()`. В коде в `SaveValue()` вызывается только `SaveProvider.SetFloat`; `Save()` нет, поэтому данные могут не попасть на диск до общего вызова Save в игре.

**Предложение:** В конце `SaveValue()` вызывать `SaveProvider.Save()` (как в Money), либо явно описать в доке, что сохранение в диск выполняется при общем Save проекта (например при выходе).

---

## Loot

### Защита от null/пустого lootItems — **Выполнено**

**Проблема (исправлено):** В `GetRandomPrefab()` и при итерации в `DropLoot()` используется `lootItems` без проверки на null. При пустом или не назначенном массиве в инспекторе возможен `NullReferenceException`.

**Предложение:** В начале `DropLoot()` и в `GetRandomPrefab()` добавить проверку:
```csharp
if (lootItems == null || lootItems.Length == 0)
    return null; // или выйти из DropLoot()
```

### Namespace — **Выполнено**

**Замечание (исправлено):** Объявление вложенного пространства имён `namespace Neo { namespace Tools {` можно заменить на `namespace Neo.Tools` для единообразия с остальными скриптами.

---

## TextScore

### Ожидание ScoreManager и повторная инициализация

**Проблема:** Используется `WaitWhile(() => ScoreManager.I == null, Init)`. Если синглтон появляется позже (например после загрузки сцены), инициализация выполняется один раз. Если объект с TextScore был выключен и снова включён после появления ScoreManager, подписка может быть корректной за счёт OnEnable/OnDisable, но стоит убедиться, что при повторном OnEnable не остаётся двойной подписки (сейчас снятие в OnDisable это предотвращает).

**Предложение (выполнено):** В Init() перед AddListener вызывается RemoveListener(Set), чтобы гарантировать одну подписку при любом порядке инициализации.

### Публичный API режима отображения

**Предложение:** Если нужно переключать режим (Current/Best) из кода или аниматора, можно добавить свойство `ScoreDisplayMode DisplayMode { get; set; }` с применением при следующем Init/OnEnable (или сразу переподписаться). Не обязательно для текущего сценария.

---

## UnityLifecycleEvents

### Инициализация UnityEvent в полях

**Замечание:** Поля UnityEvent инициализируются как `new UnityEvent()`. В Unity сериализация создаёт экземпляры при загрузке; явная инициализация защищает от null до сериализации. Всё корректно.

**Опционально:** Для единообразия с другими компонентами можно вынести заголовки/галочки в константы или оставить как есть.

---

## TypewriterEffectComponent

### Отмена при уничтожении

**Замечание:** В коде уже реализовано: OnDestroy вызывает Stop(), который отменяет CancellationTokenSource. Дополнительных изменений не требуется. (например через CancellationTokenSource.Cancel), чтобы не было обращений к уничтоженному объекту после выгрузки сцены. Если это уже реализовано в коде — достаточно пометить в документации.

---

## AttackSystem (Health и др.)

### Документация интерфейсов — **Выполнено**

**Предложение (внесено в Health):** В XML-комментариях к классу указано: «Реализует IDamageable, IHealable, IRestorable для интеграции с AttackExecution и другими компонентами». Подробнее об интерфейсах — [InterfaceAttack](./Interface/InterfaceAttack.md).

---

## Общие рекомендации

1. **Необязательная проверка в OnValidate:** В компонентах с массивами (Loot.lootItems, ScoreManager.setTextScore и т.д.) при необходимости можно в OnValidate отфильтровывать null-элементы или логировать предупреждение — только если это не мешает намеренно пустым полям.
2. **Версии и обратная совместимость:** Изменения в публичном API (например SetBestScore) лучше вводить с сохранением перегрузок и помечать устаревшие методы `[Obsolete]` с указанием замены, чтобы не ломать существующие сцены и код.
3. **Документация:** После правок в скриптах обновлять соответствующие .md в Docs/Tools/Components (описание методов, примеры, см. также).
