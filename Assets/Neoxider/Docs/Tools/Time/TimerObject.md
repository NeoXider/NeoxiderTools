# Компонент Timer Object

## 1. Введение

`TimerObject` — это компонент `MonoBehaviour`, который предоставляет простой и наглядный способ создания таймеров прямо в вашей сцене Unity. В отличие от класса `Timer`, который является обычным C#-классом, `TimerObject` можно добавить на любой `GameObject` и настроить все его параметры в инспекторе.

Он идеально подходит для создания кулдаунов, обратных отсчетов, таймеров длительности эффектов или любых других временных механик, которые должны быть привязаны к конкретному объекту в сцене.

---

## 2. Описание класса

### TimerObject
- **Пространство имен**: `Neo`
- **Путь к файлу**: `Assets/Neoxider/Scripts/Tools/Time/TimerObject.cs`

**Описание**
Компонент, который управляет отсчетом времени. Он может считать как вверх, так и вниз, зацикливаться, игнорировать `Time.timeScale` и вызывать `UnityEvent` на ключевых этапах своего жизненного цикла.

**Улучшения в v5.2.21:**
- Исправлен двойной вызов событий при достижении duration в режиме looping
- При looping таймер теперь корректно перезапускается без лишних вызовов событий
- Добавлена секция "Auto Actions" для автоматических действий без кода
- Автоматическая активация/деактивация GameObjects при завершении
- Автоматический перезапуск других TimerObjects
- Добавлена визуальная анимация при старте (scale animation)
- Улучшена автоматическая настройка компонентов

**Ключевые поля**

### Timer Settings
- `duration`: Общая длительность таймера в секундах.
- `updateInterval`: Как часто (в секундах) будет обновляться таймер и вызываться события `OnTimeChanged` и `OnProgressChanged`. Минимум: `0.015`.
- `countUp`: Если `true`, таймер будет считать от 0 до `duration` (время увеличивается). Если `false`, таймер будет считать от `duration` до 0 (обратный отсчёт, время уменьшается). В обратном режиме таймер стартует с `duration` и останавливается на 0.
- `useUnscaledTime`: Если `true`, таймер будет игнорировать `Time.timeScale` (полезно для UI во время паузы).
- `looping`: Если `true`, таймер будет автоматически перезапускаться после завершения.

### Random Duration
- `useRandomDuration`: Если `true`, длительность выбирается случайно при старте (`Play()`/`StartTimer()`). Если `looping = true`, то при каждом новом цикле будет снова выбрана случайная длительность.
- `randomDurationMin`: Минимальная длительность (секунды).
- `randomDurationMax`: Максимальная длительность (секунды).

### Infinite Duration
- `infiniteDuration`: Если `true`, таймер не имеет максимума — время просто увеличивается. Прогресс/процент не обновляются. При включении автоматически отключаются `looping` и `useRandomDuration` (в `OnValidate`).

### Initial State
- `autoStart`: Если `true`, таймер запустится автоматически при включении компонента (`OnEnable`) в Play Mode. По умолчанию: `true`. Это означает, что при повторном `SetActive(true)`/`enabled = true` таймер снова запустится.
- `initialProgress`: Начальный прогресс (0-1). 0 = начало, 1 = конец. В режиме `countUp = true` это стартовая позиция от начала (0 = 0 секунд, 1 = duration). В режиме `countUp = false` это стартовая позиция от конца (0 = duration, 1 = 0 секунд).

### Visual Feedback - НОВОЕ в v5.2.21
- `enableStartAnimation`: Включить визуальную анимацию при старте.
- `startAnimationScale`: Множитель масштаба для анимации (0.5-2.0).
- `startAnimationDuration`: Длительность анимации в секундах.

**Публичные методы (Public Methods)**
- `Play()`: Запускает таймер, выставляя стартовое значение по `initialProgress`.
- `SetDuration(float newDuration, bool keepProgress = true)`: Устанавливает длительность. `keepProgress = true` сохраняет соотношение прогресса.
- `Pause(bool paused = true)`: Ставит таймер на паузу (`true`) или снимает с паузы (`false`).
- `TogglePause()`: Переключает состояние паузы.
- `Stop()`: Останавливает таймер и сбрасывает его.
- `Reset()`: Сбрасывает таймер в начальное состояние, учитывая `initialProgress` (и обновляет UI/события).
- `StartTimer(float newDuration = -1, float newUpdateInterval = -1)`: Сбрасывает и запускает таймер, опционально меняя `duration`/`updateInterval`.
- `SetTime(float time)`: Устанавливает текущее значение времени таймера.
- `GetProgress()`: Возвращает текущий прогресс таймера (от 0 до 1).
- `GetCurrentTime()`: Возвращает текущее значение времени таймера. В режиме `countUp = true` это прошедшее время (0 → duration), в режиме `countUp = false` это оставшееся время (duration → 0).
- `GetRemainingTime()`: Возвращает оставшееся время до завершения. В режиме `countUp = true` это `duration - currentTime`, в режиме `countUp = false` это `currentTime`.

**Unity Events**
- `OnTimerStarted`: Вызывается в момент запуска таймера.
- `OnTimerPaused`: Вызывается при постановке таймера на паузу.
- `OnTimeChanged` (`UnityEvent<float>`): Вызывается с интервалом `updateInterval` пока таймер активен. Передает текущее значение времени.
- `OnProgressChanged` (`UnityEvent<float>`): Вызывается с интервалом `updateInterval` пока таймер активен. Передает текущий прогресс (от 0 до 1).
- `OnTimerCompleted`: Вызывается, когда таймер завершает отсчет. **Важно**: Вызывается при каждом завершении цикла, включая случаи зацикливания (`looping = true`). Если таймер зациклен, событие будет вызываться каждый раз при достижении `duration`.

---

## 3. Как использовать

### Базовое использование (без кода)

1.  Добавьте компонент `TimerObject` на любой `GameObject` в вашей сцене.
2.  Настройте `duration`, `updateInterval`, `countUp`, `useUnscaledTime` и `looping` в инспекторе.
3.  **Для автоматического обновления UI**: 
    - Добавьте компонент `Image` на тот же объект для прогресс-бара (автоматически найдет)
    - Или добавьте `TMP_Text` для отображения времени (автоматически найдет)
    - Настройте `timeFormat` для форматирования текста
4.  **Для визуальной анимации** (v5.2.21):
    - Включите `enableStartAnimation`
    - Настройте `startAnimationScale` и `startAnimationDuration`

### Использование через код

```csharp
// Получить текущий прогресс
float progress = timerObject.Progress;

// Установить время
timerObject.SetTime(5.0f);

// Добавить время
timerObject.AddTime(2.0f);

// Подписаться на события
timerObject.OnTimerCompleted.AddListener(() => {
    Debug.Log("Таймер завершен!");
});
```

